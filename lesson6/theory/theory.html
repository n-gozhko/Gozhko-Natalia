<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css"> 
    <title>Theory</title>
</head>
<body>
    <h2>Стилевой селектор [атрибут] — соответствует всем элементам, имеющим данный атрибут, т.е. тегам, у которых данный атрибут установлен (в любое значение).</h2>

    <h2>Стилевой селектор [атрибут=значение] — соответствует всем элементам, имеющим данный атрибут, равный данному значению.</h2>
    <p>Муравьиные семьи могут существовать на протяжении долгого периода времени.</p>
    <p align="center">Королева может жить до 20 лет, рабочие особи живут от 1 до 3 лет.</p>
    <p>Самцы живут всего несколько недель.</p>
    <p align="right">Муравьиные королевы живут в 100 раз дольше, чем большинство одиночных насекомых аналогичного размера.</p>

    <h2>Стилевой селектор [атрибут^=значение] — соответствует всем элементам, у которых значение данного атрибута начинается с указанного значения.</h2>
    <p>Королева может жить до 20 лет, рабочие особи <a href="test.html" target="Info">живут</a> от 1 до 3 лет.</p>
    <p>Самцы, <a href="http://www.site.com/p.html">однако</a>, живут всего несколько недель.</p>

    <h2>Стилевой селектор [атрибут$=значение] — соответствует всем элементам, у которых значение данного атрибута заканчивается на указанное значение.</h2>
    <p><a href="images/queen.png">Королева</a> может жить до 20 лет, <a href="images/worker.gif">рабочие особи</a> живут от 1 до 3 лет.</p>

    <h2>Стилевой селектор [атрибут*=значение] — соответствует всем элементам, у которых значение данного атрибута содержит указанное значение.</h2>
    <p><a href="images/queen.png">Королева</a> может жить до 20 лет, <a href="images/worker.gif">рабочие особи</a> живут от 1 до 3 лет.</p>

    <h2>Селектор элементов по нескольким критериям сразу</h2>
    <p>Любые виды селекторов можно объединять простым склеиванием, БЕЗ ПРОБЕЛА. Например:</p>
    <ul>
        <li>стилевой селектор div.out соответствует тегам DIV, имеющим класс "out";</li>
        <li>стилевой селектор div.out.main соответствует тегам DIV, имеющим одновременно классы "out" и "main";</li>
        <li>стилевой селектор a#main соответствует тегу A, имеющему идентификатор "main";</li>
        <li>стилевой селектор img[src$='.jpeg'] соответствует тегам IMG, у которых атрибут SRC заканчивается на ".jpeg";</li>
        <li>стилевой селектор a.back[href^='http://'] соответствует тегам A, имеющим класс "back", у которых атрибут HREF начинается на "http://".</li>
    </ul>

    <h2>Иерархические селекторы</h2>
    <p>Иерархический стилевой селектор селектор1 селектор2 — соответствует всем элементам, подходящим под селектор2, и в то же время являющимся дочерними или внучатыми к элементу, подходящему под селектор1.</p>
    <p>Иерархический стилевой селектор селектор1 > селектор2 — соответствует всем элементам, подходящим под селектор2, и в то же время являющимся дочерними к элементу, подходящему под селектор1.</p>
    <p>пример:</p>
    <p>Муравьиные семьи могут существовать на протяжении долгого периода времени.</p>
    <p>Королева может жить <span>до 20 лет</span>, рабочие особи живут от 1 до 3 лет.</p>
    <p>Самцы, однако, <i>живут всего <span>несколько недель</span></i>.</p>
    <br><br>
    <p>Иерархический стилевой селектор селектор1 + селектор2 — соответствует всем элементам, подходящим под селектор2, которые в своём контейнере идут сразу после элемента, подходящего под селектор1.</p>
    <p>Проще говоря. Стиль ляжет только на следующий тег после указанного. И только на один</p>
    <p>Иерархический стилевой селектор селектор1 ~ селектор2 — соответствует всем элементам, подходящим под селектор2, которые в своём контейнере идут после элемента, подходящего под селектор1.</p>
    <p>Стиль ляжет на все последующиеэ элементы, которые находятся на одному уровне. Чтобы ее прописать, нужно зажать на клавиатуре alt126</p>

    <h3></h3>
    <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Aspernatur tempore maiores quia, laborum deleniti facilis nobis repudiandae ad laudantium saepe itaque error vitae ex enim fugit iste fugiat perferendis hic.</p>
    <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Aspernatur tempore maiores quia, laborum deleniti facilis nobis repudiandae ad laudantium saepe itaque error vitae ex enim fugit iste fugiat perferendis hic.</p>
    
    <h4></h4>
        <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Eum dolorum laudantium dolore autem consequuntur veritatis esse nihil. Dicta reprehenderit dolore porro necessitatibus sint dolorem saepe ipsum fugiat, ex consequatur iusto.</p>
        <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Eum dolorum laudantium dolore autem consequuntur veritatis esse nihil. Dicta reprehenderit dolore porro necessitatibus sint dolorem saepe ipsum fugiat, ex consequatur iusto.</p>
    
    <h5></h5>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Neque, quo sapiente veniam ea saepe accusantium animi blanditiis consequuntur, voluptatibus ducimus voluptates numquam, facere earum totam deserunt architecto esse possimus voluptate?</p>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Neque, quo sapiente veniam ea saepe accusantium animi blanditiis consequuntur, voluptatibus ducimus voluptates numquam, facere earum totam deserunt architecto esse possimus voluptate?</p>
    








        
    <h2>Селекторы псевдоклассов</h2>
    <p>Псевдоклассы — подразумеваемые стилевые классы, к которым элементы (теги) автоматически относятся на основании каких-либо признаков.</p>
    <p>Стилевой селектор псевдокласса :first-child — соответствует тем элементам, которые в своём контейнере является первыми.</p>
    <p>Стилевой селектор псевдокласса :last-child — соответствует тем элементам, которые в своём контейнере является последними.</p>

    <div>
        <p>Муравьиные семьи могут существовать на протяжении долгого периода времени.</p>
        <p>Королева может жить до 20 лет.</p>
        <p>Рабочие особи живут от 1 до 3 лет.</p>
    </div>
    <div>
        <p>Самцы, однако, живут всего несколько недель.</p>
        <p>Муравьиные королевы живут в 100 раз дольше, чем большинство одиночных насекомых аналогичного размера.</p>
    </div>
    <br><Br>
        

        <h2>Стилевой селектор псевдокласса :nth-child соответствует элементам, которые в своём контейнере расположены под номерами с некоторыми интервалом.</h2>
        <ul>
            <li>:nth-child(odd) — соответствует элементам, которые в своём контейнере нечётные.</li>
            <li>:nth-child(even) — соответствует элементам, которые в своём контейнере чётные.</li>
            <li>:nth-child(i) — соответствует элементу, который в своём контейнере идёт под номером i.</li>
            <li>:nth-child(an+b) — вместо n будут подставлены числа от 0 и выше; результат вычисления формулы даёт номера дочерних элементов в их контейнере; a и b должны быть целыми числами и могут быть отрицательными.</li>
        </ul>
        <img src="formula.jpg">

        <br><br>
        <table border="1">
            <tr>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
                <td>5</td>
            </tr>
            <tr>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
                <td>5</td>
            </tr>
            <tr>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
                <td>5</td>
            </tr>
            <tr>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
                <td>5</td>
            </tr>
            <tr>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
                <td>5</td>
            </tr>
        </table>
        

        <p>Стилевой селектор псевдокласса :first-of-type — соответствует тем элементам, которые в своём контейнере является первыми среди элементов того же типа, т.е. того же тега.</p>
        <p>Стилевой селектор псевдокласса :last-of-type — соответствует тем элементам, которые в своём контейнере является последними среди элементов того же типа, т.е. того же тега.</p>    
        <p> Обычно комбинируются с селектором по тегу.</p>
        
        <div>
            <h3>МУРАВЬИНАЯ СЕМЬЯ</h3>
            <p>Муравьиные семьи могут существовать на протяжении долгого периода времени.</p>
            <h3>КОРОЛЕВА</h3>
            <p>Королева может жить до 20 лет.</p>
            <i>использованная литература...</i>
        </div>
        <br><br>
        <p>Стилевой селектор псевдокласса :nth-of-type соответствует элементам, которые в своём контейнере расположены под номерами с некоторыми интервалом среди элементов того же типа, т.е. того же тега. Обычно комбинируется с селектором по тегу. Варианты использования:</p>
        <ul>
            <li>:nth-of-type(odd) — соответствует элементам, которые в своём контейнере нечётные среди элементов того же типа (тега).</li>
            <li>:nth-of-type(even) — соответствует элементам, которые в своём контейнере чётные среди элементов того же типа (тега).</li>
            <li>:nth-of-type(i) — соответствует элементу, который в своём контейнере идёт под номером i среди элементов того же типа (тега).</li>
            <li>:nth-of-type(an+b) — вместо n будут подставлены числа от 0 и выше; результат вычисления формулы даёт номера дочерних элементов в их контейнере среди элементов того же типа (тега); a и b должны быть целыми числами и могут быть отрицательными.</li>
        </ul>
        <p>Работает также, как child</p>

        <h2>Стилевой селектор псевдокласса :hover — соответствует элементу, над которым сейчас находится курсор мыши.</h2>
        <p>Условно говоря, при наведении курсором на элемент - его можно изменить. Прописывается ховер через двоеточие.</p>
        <div class="aaa"></div>

        <h2>Стилевой селектор псевдокласса :active — соответствует элементу, который сейчас активирован (например, ссылка, когда на ней нажата кнопка мыши).</h2>
        <p>Т.е. это событие работает, когда мы заживаем и удерживаем кнопку мыши</p>
        <div class="bbb"></div>

        <h2>Стилевой селектор псевдокласса :focus — соответствует элементу, который сейчас имеет фокус ввода (например, поле ввода текста, в котором сейчас находится текстовый курсор).</h2>
        <p>Т.е. когда элемент у нас находится в фокусе. Например когда мы на него нажали. Пока не нажнем на пустое место на поле - элемент аходится в фокусе.</p>
        <p class="ccc">sdfghjkllkjhasdfghj <a href="http://fe.it-academy.by/Materials/HTMLCSS_V14/HTMLCSS_6.html" target="_blank">25</a></p>

        <h2>Стилевой селектор псевдокласса :link — соответствует ещё не посещённым гиперссылкам.</h2>
        <p>Работает на ссылке, которую мы еще не посещали</p>
        <p class="ccc">sdfghjkllkjhasdfghj <a href="http://fe.it-academy.by/Materials/HTMLCSS_V14/HTMLCSS_6.html" target="_blank">25</a></p>
    
        <h2>Стилевой селектор псевдокласса :visited — соответствует уже посещённым гиперссылкам.</h2>
        <p>Работает на ссылке, которую мы уже посетили. Даже если мы сбрасываем кэш - все равно показано, что мы ее уже посещали. Только если мы удалим историю браузера</p>
        <p class="ccc">sdfghjkllkjhasdfghj <a href="https://translate.yandex.by/translator/en-ru?ui=ru" target="_blank">25</a></p>

        <h2>Стилевой селектор псевдокласса :target — соответствует тем элементам, идентификатор (HTML-атрибут id) которых сейчас указан в закладке УРЛа страницы.</h2>
        <p>Напрмер, когда мы делаем ссылку на какой-то id-шник, и нажимаем по этомй ссылке - сверху в кодовой строке у нас пропсиывается называние этого id. Таргет соответствует этим элементам</p>
        
        <h2>Стилевой селектор псевдокласса :not(сел) — соответствует элементам, не подходящим под указанный селектор сел</h2>
        <p>Селектор сел не может быть любым, есть некоторые ограничения; например, в нём не допускается использование псевдоэлементов (о них ниже).
        Обычно селектор :not комбинируется с селекторами других видов.<br>
        Но им обычно не пользуются, т.к. начинает подтупливать страница. Лучше другим способом зазменить.</p>
        <p>При этом, задавать отдельно стиль для остальных классов не нужно.</p>
        
        <div class="a1">
            <div class="header1">Заголовок 1</div>
            <div class="header2">Заголовок 2</div>
            <div>текст текст текст</div>
            <div class="info">информация информация</div>
            <div class="remark">примечание</div>
            <div class="info">текст текст текст</div>
            <p>абзац абзац абзац</p>
        </div>
        <h2>Селектор элементов по нескольким критериям сразу с использованием псевдоклассов</h2>
        <p>Любые виды селекторов, в том числе и селекторы псевдоклассов, можно объединять простым склеиванием, без пробела. Например:</p>
        <ul>
            <li>стилевой селектор a.nav:visited:hover соответствует тегам A, имеющим класс "nav", ведущим на уже посещённую ссылку, если к ним сейчас поднесён курсор мыши;</li>
            <li>стилевой селектор img[src$='.jpg']:first-child соответствует тегам IMG, отображающим картинку с расширением jpg, если картинка является первым элементом в своём контейнере;</li>
            <li>стилевой селектор tr:not(:first-child):not(:last-child) соответствует всем строкам таблиц, кроме первой и последней.</li>
        </ul>









        <h2>Селекторы псевдоэлементов</h2>
        <p>Псевдоэлементы — подразумеваемые элементы, не являющиеся обычными HTML-элементами (тегами).<br>
        Стилевой селектор псевдоэлемента ::first-line — соответствует первой строке элементов.</p>
        <div class="a2">
            <h6>МУРАВЬИНАЯ <b>СЕМЬЯ</b></h6>
            <div>
            <p>Муравьиные семьи могут существовать на протяжении долгого периода времени.</p>
            <p>Муравьиные королевы живут в 100 раз дольше, чем многие насекомые аналогичного размера.</p>
            </div>
        </div>

        <p>Стилевой селектор псевдоэлемента ::first-letter — соответствует первому символу элементов.</p>
        <div class="a3">
            <h6>МУРАВЬИНАЯ <b>СЕМЬЯ</b></h6>
            <div>
            <p>Муравьиные семьи могут существовать на протяжении долгого периода времени.</p>
            <p>Муравьиные королевы живут в 100 раз дольше, чем многие насекомые аналогичного размера.</p>
            </div>
        </div>

        <h2>Стилевой селектор псевдоэлемента ::before — соответствует (несуществующему) содержимому, расположенному перед содержимым парных элементов.</h2>
        <h2>Стилевой селектор псевдоэлемента ::after — соответствует (несуществующему) содержимому, расположенному после содержимого парных элементов.</h2>            
        <p>Это несуществующее содержимое можно задать стилевым свойством content. Они относятся непосредстввенно к своему родителю. Они также могут отдельно стилизоваться</p>
        <p>Стилевое свойство content — позволяет задать генерируемое содержимое. Применяется к элементам, содержимое которых изначально отсутствует в тексте веб-страницы. Обычно применяется вместе с селекторами псевдоэлементов ::before и ::after.
        <br>Обязательно прописывать сначала content и в кавычках значение, иначе работать не будет</p>            
        <p><span>первый</span></p>
        <p><span>второй</span></p>
        <p><span>третий</span></p>
        <p><span>четвертый</span></p>
        
        <p>Некоторые возможные значения:</p>
        <ul>
            <li>content: none — нет генерируемого содержимого.</li>
            <li>content: 'текст' — задаёт текст в качестве генерируемого содержимого; текст не может содержать HTML-тегов или HTML-сущностей (мнемоник).</li>
            <li>content: url('ссылка') — задаёт изображение, расположенное по ссылке, в качестве генерируемого содержимого.</li>
            <li>content: attr(атрибут) — задаёт значение HTML-атрибута тега в качестве генерируемого содержимого.</li>
            <li>content: counter(счётчик) — задаёт значение счётчика; CSS-счётчик может быть сброшен в каких-либо тегах стилевым свойством counter-reset: счётчик и может быть увеличен в каких-либо тегах стилевым свойством counter-increment: счётчик.</li>
            <li>content: значение1 значение2 значение3... — может быть скомбинировано любое количество значений вышеуказанных форматов.</li>
        </ul>
        <p>Если необходимо сделать какой-то свой атрибут, т.е. кастомный, то чтобы его интерпретатор читал и валидатор не выдавал ошибок, нужно использовать приставку data-. Например: data-book</p>
        <p>Инкрементировать - т.е. увеличить число на 1 единицу. Декрементировать - уменьшить на одну единицу</p>
        <p>Счетчик. Задаем ему название - planet. Первая строчка counter-reset означает, что как только мы доходим до h3 наш счетчик обнуляется. 
            Далее мы перед тегом p прописываем наш счетчик planet, в контент мы пишем то, что хотим увидеть + значение счетчика. Т.к. ранее мы поставили increment, то каждый
            последующий раз счетчик будет увеличиваться на 1. пока не дойдёт до h3 и снова начнет сначала.<br> Подробнее см. код в комментариях
        </p>
        <!--
            <style>
                h3 { counter-reset: planet }
                p::before
                {
                    counter-increment: planet;
                    content: 'Планета ' counter(planet) '. '
                }
            </style>
            <h3>Планеты до Земли</h3>
            <p>Меркурий</p><p>Венера</p>
            <h3>Планеты после Земли</h3>
            <p>Марс</p><p>Юпитер</p><p>Сатурн</p>-->
        <h2>clearfix</h2>
        <p>При вёрстке макетов часто требуется, чтобы размер контейнера включал в себя размеры всех дочерних элементов, в том числе плавающих. Обычно же размер контейнера НЕ включает в себя размеры плавающих дочерних элементы.</p>
        <p>Проблема может быть решена выставлением стилевого свойства overflow:hidden или overflow:auto у контейнера, либо же можно сделать сам контейнер плавающим через float:left или float:right. Однако, эти способы неуниверсальны — эти стилевые свойства могут повлиять на поведение контейнера. Более универсальный способ, который мы тоже уже знаем — добавление в контейнер тега со стилевым свойством clear:both.</p>
       <p>Недостаток такого способа, в приведённом виде — семантический: мы добавили HTML-тег, который НЕ имеет отображаемого смысла, НЕ задаёт ни содержание, ни логическую разметку, т.е. служебный, технический.
        С помощью селектора псевдоэлемента :after можно сделать код семантичнее:</p>
            <style>
                .s-inner { float: left; width: 80px; height: 80px; background: yellow }
                .clearfix::after { content: " "; display: block; clear: both; }
            </style>
            <div style="border: solid red 1px" class="clearfix">
                <div class="s-inner"></div>
            </div>
        <p>Или, кроссбраузерный вариант:</p>
            <style>
                .s-inner2 { float: left; width: 80px; height: 80px; background: yellow }
                .clearfix2:after { content: "."; visibility: hidden; display: block;
                    height: 0; clear: both }
            </style>
            <div style="border: solid red 1px" class="clearfix2">
                <div class="s-inner2"></div>
            </div>
        <h2>Комбинированные селекторы</h2>
        <p>Можно несколько селекторов перечислить через запятую, тогда указанное стилевое оформление будет применено к тегам, подходящим под любой из перечисленных селекторов.
        </p>
        <style>
            a[href*='//']
            {
                color: red;
            }
            a:not([href*='//'])
            {
                color: green;
            }
        </style>
        Эта <a href="http://www.tut.by">ссылка</a> абсолютная,<br>
        и эта <a href="https://www.tut.by">ссылка</a> тоже,<br>
        и эта <a href="//www.tut.by">ссылка</a> абсолютная,<br>
        а вот эта <a href="Examples/sml.gif">ссылка</a> относительная.

        <h2>Веса стилевых селекторов</h2>
        <p>В случае, когда для какого-либо элемента есть сразу несколько стилевых описаний, которые к нему применяются, будут применены те стилевые свойства, стилевые описания которых имеют больший вес.</p>
        <p>В случае указания стилевых описаний в элементе style, вес каждого стилевого описания зависит от селективности (выборочности, точности) его селектора. Чем точнее селектор, тем больше вес стилевых описаний, ему соответствующих.
        <br>Для простоты, можно считать так:</p>
        <ul>
            <li>каждый тег в селекторе добавляет к весу стилевого описания 1;</li>
            <li>каждый класс и каждый псевдокласс в селекторе добавляет к весу стилевого описания 10;</li>
            <li>каждый идентификатор в селекторе добавляет к весу стилевого описания 100.</li>
        </ul>
        <p>Например, стилевое описание с селектором p.info span имеет вес 1+10+1 = 12, а стилевое описание с селектором #queen span — вес 101.
        <br>Если стилевое описание не вынесено в элемент style, а указано непосредственно в элементе в атрибуте style, то такое стилевое описание имеет вес 1000.</p>
        <p>При указании в любом стилевом описании специального признака !important, вес стилевого описания увеличивается в 10.000 раз.</p>
        <style>
            p.ves { color: red }
            div p.ves { color: blue; font-style: italic }
        </style>
        <p class="ves">Мохаммед Али &mdash; американский боксёр-профессионал, выступавший в тяжёлой весовой категории.</p>
        <div>
            <p class="ves" style="color: green">Один из самых известных и узнаваемых спортсменов в истории.</p>
            <p class="ves">После чемпионского боя с Сонни Листоном сменил имя на Кассиус Икс,
        затем на <b>Мохаммед Али</b>.</p>
        </div>
        <p>Браузер, когда ищет для элемента значение какого-либо стилевого свойства, ищет его по следующему алгоритму:</p>
        <ol>
            <li>Проверяет стилевые правила в теге style, селекторы которых подходят к данному элементу, а также атрибут style этого элемента — если данное стилевое свойство где-либо указано, берётся его значение; если указано в нескольких местах — берётся значение из описания, имеющего наибольший вес.</li>
            <li>Если п.1 не дал результатов, проверяются умолчательные стилевые описания тега в браузере; если данное стилевое свойство в них указано — берётся значение оттуда.</li>
            <li>Если и п.2 не дал результатов, значения некоторых стилевых свойств элемента берутся из аналогичных стилевых свойств его контейнера.</li>
        </ol>
        <p>Данные шаги браузер предпринимает по каждому стилевому свойству каждого элемента в отдельности.</p>
        <p>Поэтому, если для элемента любым способом установлен его собственный стиль (п.1), нет никакой возможности повлиять на этот стиль, устанавливая стиль контейнера элемента (п.3):</p>
        <p style="text-align: center;">Итак, по приоритетам сначала идет:<br>
        Стиль по тегу (p). Вес 1 единица ><br>
        Стиль по классу (.aaa). Вес 10 единиц ><br>
        Стиль по идентификатору (#id). Вес 100 единиц ><br>
        Инлайновый стиль. Вес 1000 единиц ><br>
        !important. Вес 10000 единиц<br>
        </p>

        <h2>Управление режимом отображения элементов</h2>
        <p>Стилевое свойство display — управление режимом отображения элемента.<br>
        С помощью его мы можем делать из блочного элемента инлайновый, или наоборот. Также можем задавать элементу все свойства инлайнового элемента и блочного.
        <br>Некоторые возможные значения:</p>
            <ul>
                <li>display: block — элемент должен отображаться как блочный (он начинается с новой строки, контент после него начинается с новой строки). Такой элемент автоматически растягивается на всю ширину контейнера, и имеет такую высоту, какая нужна, чтобы вместить всё его содержимое.</li>
                <li>display: inline — элемент должен отображаться как текстовый (внутристрочный). Понятия «ширина» и «высота» для него не имеют смысла.</li>
                <li>display: inline-block — элемент должен отображаться как блочный, но не с новой строки, а в той же строке, т.е. такие элементы, будучи блочными, выстраиваются в одну строку (выровненную по базовой линии строки). Такой элемент, в отличие от блочных, не растягивается на всю доступную ему ширину, а имеет такую ширину и высоту, какие необходимы, чтобы вместить всё его содержимое.</li>
                <li>display: inline-table — элемент должен отображаться как таблица, но в той же строке.</li>
                <li>display: none — элемент и всё его содержимое не отображаются и не занимают места на веб-странице. Данное значение может быть применено для удаления ячеек таблицы.</li>
                <li>Также возможны значения display: list-item, display: table-row и другие.</li>
            </ul>
            <img src="pic2.jpg">

            <h2> Управление видимостью элементов</h2>
            <p>Стилевое свойство visibility — видимость элемента.
            <br>Возможные значения:</p>
            <ul>
                <li>visibility: visible — видимый элемент (как обычно).</li>
                <li>visibility: hidden — элемент и всё его содержимое невидимы, при этом они занимают положенное им место на веб-странице, в отличие от display: none.</li>
                <li>Есть также ещё значения collapse, empty-cells.</li>
            </ul>
            <p>РАЗНИЦА МЕЖДУ display none И visibility hidden в том, что второй скрывает элемент, но оставляет под него пустое место.</p>
            <p>При display none, если мы скроем весь блок, то отобразить какой-то из его элементов не получится.<br>
            В том время как, при  visibility hidden, мы можем скрыть весь блок (div), а какой-нибудь элемент при необходимости отразить (span)</p>
            <img src="pic3.jpg">
            
            <h2>Стилевое свойство opacity — непрозрачность элемента и всего его содержимого.
            <br>Возможные значения:</h2>
            <ul>
                <li>opacity: непрозрачность, где непрозрачность — дробное число от 0 до 1.</li>
                <li>Значение 1 означает полностью видимый элемент,</li>
                <li>значение 0 — полностью невидимый (аналогично visibility: hidden).</li>
            </ul>
            <img src="pic4.jpg">


        
            <h2>Файл resert</h2>
            <p>Он необходим для того, чтобы сброить все стили с тегов по умолчанию. Чтобы в style не прописывать каждый тег отдельно.
                <br>Лучше скопировать этот файл и подключать к стилям его отдельно.<br>
                P.S. СМОТРИ отдельный файл resert. Но при этом, ссылку на этот файл нужно ставить первую. Перед нашими стилями, т.к. интерпретатор читает сверху.
                То, что находится ниде строчкой - более важное и перебьет то, что написано выше.
            </p>


            <h2>Есть такой готовый файл, как normalize.css</h2>
            <p>Есть такая проблема, что все браузеры писали разные разработчики, и один и тот же шрифт установленный в коде, может отоьражаться по-разному на разных браузерах.
            Для этого и используют файл normalize. Он оптимизирует отображение одинаковое во всех браузерах.
            <br>Смотри файл normalize.css. Причем его устанавливать надо выше, чем файл reset.
        </p>

        <h2>Методология БЭМ (yandex).</h2>
        <p>Например у нас такая ситуация, что два разработчика делают проект. У них два разных файла со стилями. И в каждом файле присутствует класс с одинаковым названием.
            <br>Получится, когда мы пропишем путь на два этих файла, интерпретатор начнет их считывать, и стиль на этот класс будет браться из второго файла.
            Для того, чтобы минимизировать такие ситуации, используется Методология БЭМ - блок, элемент, индетификатор
            <br>Т.е., у нас есть определенная структура названия классов, блоков, и мы договариываемся с разработчиком другим, что будем ее придерживаться.
            <br>Пример ниже в картинке
        </p>
        <img src="pic5.jpg">
        <p>но бывает такое, что два человека читают методологию по-разному.</p>

        <p>
        Можно сделать маленькие картинки, а нажатием на них открывать большие. Но для этого нужно, чтобы у нас хранились все картинки маленького размера и все большого.
        <br> Мы можем большие скрыть с помощью свойства display none. Но интерпретатор будет все равно ее загружать.
        <br>В таком случае, сайт будет загружаться долго, особенно, если у нас мног окартинок/
        <br>Поэтому, лучше использовать картинки как задний фон и ставить на него ховеры с ссылкой на картинку нужного размера, чтобы она отображалась, когда это необходимо
        <br>Таким образом, у нас будут грузиться картинки только при необходимости, по одному, при наведении на нее, а не все сразу</p>











<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

</body>
</html> 